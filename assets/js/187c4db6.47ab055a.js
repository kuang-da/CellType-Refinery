"use strict";(globalThis.webpackChunkcelltype_refinery_docs=globalThis.webpackChunkcelltype_refinery_docs||[]).push([[2074],{8453(e,n,i){i.d(n,{R:()=>s,x:()=>o});var t=i(6540);const r={},a=t.createContext(r);function s(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(a.Provider,{value:n},e.children)}},9921(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"core-workflows/iterative-refinement","title":"Iterative Refinement Workflow","description":"The iterative workflow enables multiple rounds of refinement for complex tissues.","source":"@site/docs/core-workflows/iterative-refinement.md","sourceDirName":"core-workflows","slug":"/core-workflows/iterative-refinement","permalink":"/CellType-Refinery/docs/core-workflows/iterative-refinement","draft":false,"unlisted":false,"editUrl":"https://github.com/kuang-da/CellType-Refinery/tree/main/celltype-refinery-docs/docs/core-workflows/iterative-refinement.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"docsSidebar","previous":{"title":"Hybrid Workflow","permalink":"/CellType-Refinery/docs/core-workflows/hybrid-workflow"},"next":{"title":"Preprocessing Overview","permalink":"/CellType-Refinery/docs/modules/preprocessing/overview"}}');var r=i(4848),a=i(8453);const s={sidebar_position:5},o="Iterative Refinement Workflow",l={},c=[{value:"Overview",id:"overview",level:2},{value:"When to Use",id:"when-to-use",level:2},{value:"Iteration Tracking",id:"iteration-tracking",level:2},{value:"CLI Workflow",id:"cli-workflow",level:2},{value:"Iteration 1: Baseline",id:"iteration-1-baseline",level:3},{value:"Iteration 2+: Targeted Refinement",id:"iteration-2-targeted-refinement",level:3},{value:"Continue Until Satisfied",id:"continue-until-satisfied",level:3},{value:"Python API",id:"python-api",level:2},{value:"Stopping Criteria",id:"stopping-criteria",level:2},{value:"Lineage Tracking",id:"lineage-tracking",level:2},{value:"Example: 3-Iteration Workflow",id:"example-3-iteration-workflow",level:2},{value:"Iteration 1: Auto Baseline",id:"iteration-1-auto-baseline",level:3},{value:"Iteration 2: Target Unassigned",id:"iteration-2-target-unassigned",level:3},{value:"Iteration 3: Fine-tune",id:"iteration-3-fine-tune",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Visualization",id:"visualization",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"iterative-refinement-workflow",children:"Iterative Refinement Workflow"})}),"\n",(0,r.jsx)(n.p,{children:"The iterative workflow enables multiple rounds of refinement for complex tissues."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.mermaid,{value:"flowchart TB\n    A[Initial Annotation] --\x3e B[Iteration 1]\n    B --\x3e C{Quality OK?}\n    C --\x3e|No| D[Review & Configure]\n    D --\x3e E[Iteration 2]\n    E --\x3e F{Quality OK?}\n    F --\x3e|No| G[Review & Configure]\n    G --\x3e H[Iteration N]\n    H --\x3e I{Quality OK?}\n    I --\x3e|Yes| J[Final Results]\n    C --\x3e|Yes| J\n    F --\x3e|Yes| J"}),"\n",(0,r.jsx)(n.h2,{id:"when-to-use",children:"When to Use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Complex tissues with many cell types"}),"\n",(0,r.jsx)(n.li,{children:"Unexpected populations discovered during annotation"}),"\n",(0,r.jsx)(n.li,{children:"Need to explore different granularity levels"}),"\n",(0,r.jsx)(n.li,{children:"Publication requiring thorough validation"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"iteration-tracking",children:"Iteration Tracking"}),"\n",(0,r.jsx)(n.p,{children:"Each iteration creates versioned outputs:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"output/\n\u251c\u2500\u2500 iter1/\n\u2502   \u251c\u2500\u2500 refined.h5ad\n\u2502   \u251c\u2500\u2500 diagnostic_report.csv\n\u2502   \u2514\u2500\u2500 curation_log.json\n\u251c\u2500\u2500 iter2/\n\u2502   \u251c\u2500\u2500 refined.h5ad\n\u2502   \u251c\u2500\u2500 diagnostic_report.csv\n\u2502   \u2514\u2500\u2500 curation_log.json\n\u2514\u2500\u2500 iter3/\n    \u2514\u2500\u2500 ...\n"})}),"\n",(0,r.jsx)(n.h2,{id:"cli-workflow",children:"CLI Workflow"}),"\n",(0,r.jsx)(n.h3,{id:"iteration-1-baseline",children:"Iteration 1: Baseline"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Initial annotation\ncelltype-refinery annotate \\\n  --input clustered.h5ad \\\n  --marker-map markers.json \\\n  --out output/iter0\n\n# First refinement round\ncelltype-refinery refine \\\n  --input output/iter0/annotated.h5ad \\\n  --auto \\\n  --execute \\\n  --out output/iter1\n"})}),"\n",(0,r.jsx)(n.h3,{id:"iteration-2-targeted-refinement",children:"Iteration 2+: Targeted Refinement"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Review iter1 results, create config\ncat output/iter1/diagnostic_report.csv\n\n# Apply targeted corrections\ncelltype-refinery refine \\\n  --input output/iter1/refined.h5ad \\\n  --config iter2_curation.yaml \\\n  --execute \\\n  --out output/iter2\n"})}),"\n",(0,r.jsx)(n.h3,{id:"continue-until-satisfied",children:"Continue Until Satisfied"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Iteration 3\ncelltype-refinery refine \\\n  --input output/iter2/refined.h5ad \\\n  --config iter3_curation.yaml \\\n  --execute \\\n  --out output/iter3\n\n# ... and so on\n"})}),"\n",(0,r.jsx)(n.h2,{id:"python-api",children:"Python API"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from celltype_refinery.core.refinement import RefinementEngine\nfrom pathlib import Path\n\ndef run_iteration(input_path, config_path, output_dir, iteration):\n    """Run one refinement iteration."""\n    import scanpy as sc\n\n    adata = sc.read_h5ad(input_path)\n    engine = RefinementEngine()\n    engine.load(adata)\n\n    if config_path:\n        plan = engine.create_manual_plan(config_path)\n    else:\n        plan = engine.create_auto_plan()\n\n    engine.execute(plan)\n\n    out = Path(output_dir) / f"iter{iteration}"\n    out.mkdir(parents=True, exist_ok=True)\n    adata.write_h5ad(out / "refined.h5ad")\n\n    return adata\n\n# Run iterations\nadata = run_iteration("annotated.h5ad", None, "output", 1)\nadata = run_iteration("output/iter1/refined.h5ad", "iter2.yaml", "output", 2)\nadata = run_iteration("output/iter2/refined.h5ad", "iter3.yaml", "output", 3)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"stopping-criteria",children:"Stopping Criteria"}),"\n",(0,r.jsx)(n.p,{children:"Use the diagnostic report to decide when to stop:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import pandas as pd\n\ndef check_stopping_criteria(diagnostic_path):\n    """Check if refinement should continue."""\n    diag = pd.read_csv(diagnostic_path)\n\n    # Criteria\n    unassigned_rate = (diag["assigned_label"] == "Unassigned").mean()\n    low_confidence = (diag["confidence"] == "LOW").mean()\n    subcluster_needed = (diag["recommendation"] == "SUBCLUSTER").sum()\n\n    print(f"Unassigned rate: {unassigned_rate:.1%}")\n    print(f"Low confidence: {low_confidence:.1%}")\n    print(f"Clusters needing subcluster: {subcluster_needed}")\n\n    # Stop if all criteria met\n    if unassigned_rate < 0.10 and low_confidence < 0.15 and subcluster_needed == 0:\n        print("Stopping criteria met!")\n        return True\n    return False\n\n# Check after each iteration\ncheck_stopping_criteria("output/iter2/diagnostic_report.csv")\n'})}),"\n",(0,r.jsx)(n.h2,{id:"lineage-tracking",children:"Lineage Tracking"}),"\n",(0,r.jsx)(n.p,{children:"CellType-Refinery tracks cell lineage across iterations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# Access lineage information\nprint(adata.obs["cell_lineage"].value_counts())\n\n# Example lineage chain\n# "0:1:2" means: cluster 0 \u2192 subcluster 1 \u2192 sub-subcluster 2\n'})}),"\n",(0,r.jsx)(n.h2,{id:"example-3-iteration-workflow",children:"Example: 3-Iteration Workflow"}),"\n",(0,r.jsx)(n.h3,{id:"iteration-1-auto-baseline",children:"Iteration 1: Auto Baseline"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"# Auto-generated actions:\n# - Subcluster 5 low-scoring clusters\n# - Skip 28 high-confidence clusters\n# - 1 cluster marked ambiguous\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Results"}),": 82% assigned, 18% unassigned"]}),"\n",(0,r.jsx)(n.h3,{id:"iteration-2-target-unassigned",children:"Iteration 2: Target Unassigned"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'# iter2_curation.yaml\nsubcluster:\n  - cluster_id: "12:0"  # Unassigned subpopulation\n    resolution: 0.4\n\noverrides:\n  - cluster_id: "12:1"\n    cell_type: "Debris"\n    reason: "Low complexity, high background"\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Results"}),": 89% assigned, 8% unassigned, 3% debris"]}),"\n",(0,r.jsx)(n.h3,{id:"iteration-3-fine-tune",children:"Iteration 3: Fine-tune"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'# iter3_curation.yaml\nmerge:\n  - source_clusters: ["5:0", "5:1"]\n    target_label: "M1_Macrophages"\n    reason: "Oversplit, same profile"\n\nrelabel:\n  - from_cluster: "8:2:1"\n    to_label: "Activated_T_Cells"\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Results"}),": 91% assigned (final)"]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Track iterations"}),": Keep all outputs, don't overwrite"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Document decisions"}),": Each config should have reasons"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Review incrementally"}),": Don't make too many changes at once"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use diagnostics"}),": Let metrics guide your decisions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Know when to stop"}),": Define criteria upfront"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"visualization",children:"Visualization"}),"\n",(0,r.jsx)(n.p,{children:"Track quality across iterations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import matplotlib.pyplot as plt\n\niterations = [1, 2, 3]\nunassigned = [0.18, 0.08, 0.06]\nlow_conf = [0.25, 0.15, 0.10]\n\nfig, ax = plt.subplots()\nax.plot(iterations, unassigned, 'o-', label='Unassigned')\nax.plot(iterations, low_conf, 's-', label='Low Confidence')\nax.set_xlabel('Iteration')\nax.set_ylabel('Rate')\nax.legend()\nplt.savefig('iteration_progress.png')\n"})}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"../modules/refinement/diagnostic-mode",children:"Diagnostic Mode"})," - Understanding diagnostics"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"../modules/consolidation/overview",children:"Consolidation"})," - Final label assignment"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"../modules/review/overview",children:"Review Module"})," - Quality validation"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);