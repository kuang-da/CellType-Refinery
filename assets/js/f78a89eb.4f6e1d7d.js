"use strict";(globalThis.webpackChunkcelltype_refinery_docs=globalThis.webpackChunkcelltype_refinery_docs||[]).push([[5639],{2778(e,n,i){i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"methodology/hierarchical-gating-algorithm","title":"Hierarchical Gating Algorithm","description":"This page explains the assignment algorithm. For scoring details, see Marker Scoring Algorithm first.","source":"@site/docs/methodology/hierarchical-gating-algorithm.md","sourceDirName":"methodology","slug":"/methodology/hierarchical-gating-algorithm","permalink":"/CellType-Refinery/docs/methodology/hierarchical-gating-algorithm","draft":false,"unlisted":false,"editUrl":"https://github.com/kuang-da/CellType-Refinery/tree/main/celltype-refinery-docs/docs/methodology/hierarchical-gating-algorithm.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Marker Scoring Algorithm","permalink":"/CellType-Refinery/docs/methodology/marker-scoring-algorithm"},"next":{"title":"Refinement Decision Logic","permalink":"/CellType-Refinery/docs/methodology/refinement-decision-logic"}}');var r=i(4848),t=i(8453);const l={sidebar_position:4},o="Hierarchical Gating Algorithm",a={},c=[{value:"Overview: Top-Down Traversal",id:"overview-top-down-traversal",level:2},{value:"Marker Hierarchy Structure",id:"marker-hierarchy-structure",level:3},{value:"Gate Check Sequence",id:"gate-check-sequence",level:2},{value:"Gate Check Details",id:"gate-check-details",level:3},{value:"Base Gating Parameters",id:"base-gating-parameters",level:2},{value:"Parameter Interpretation",id:"parameter-interpretation",level:3},{value:"Assignment Algorithm",id:"assignment-algorithm",level:2},{value:"Algorithm Pseudocode",id:"algorithm-pseudocode",level:3},{value:"Key Decision Points",id:"key-decision-points",level:3},{value:"Stop Reasons Explained",id:"stop-reasons-explained",level:2},{value:"Detailed Stop Reason Analysis",id:"detailed-stop-reason-analysis",level:3},{value:"Confidence Calculation",id:"confidence-calculation",level:2},{value:"Confidence Interpretation",id:"confidence-interpretation",level:3},{value:"Margin Calculation Example",id:"margin-calculation-example",level:3},{value:"Per-Cell Voting (Evidence Collection)",id:"per-cell-voting-evidence-collection",level:2},{value:"How Per-Cell Voting Works",id:"how-per-cell-voting-works",level:3},{value:"Important Constraints",id:"important-constraints",level:3},{value:"Voting Output Format",id:"voting-output-format",level:3},{value:"Handling Edge Cases",id:"handling-edge-cases",level:2},{value:"Missing Markers",id:"missing-markers",level:3},{value:"Single-Child Nodes",id:"single-child-nodes",level:3},{value:"Negative Markers Only",id:"negative-markers-only",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"hierarchical-gating-algorithm",children:"Hierarchical Gating Algorithm"})}),"\n",(0,r.jsx)(n.admonition,{title:"Prerequisites",type:"info",children:(0,r.jsxs)(n.p,{children:["This page explains the assignment algorithm. For scoring details, see ",(0,r.jsx)(n.a,{href:"/CellType-Refinery/docs/methodology/marker-scoring-algorithm",children:"Marker Scoring Algorithm"})," first."]})}),"\n",(0,r.jsx)(n.h2,{id:"overview-top-down-traversal",children:"Overview: Top-Down Traversal"}),"\n",(0,r.jsx)(n.p,{children:"The hierarchical gating algorithm is the core decision engine that assigns cell type labels to clusters. It traverses a marker hierarchy from roots to leaves, making competitive decisions at each level based on marker expression evidence."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key principles:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Start at root categories"})," (Epithelium, Immune, Mesenchymal, etc.)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Descend through the hierarchy"})," following the strongest signal"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Only siblings compete at each level"})," - unrelated branches never compete directly"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stop when uncertain"})," - ambiguous cases preserve the most specific confident label"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:'The algorithm prioritizes accuracy over specificity. It is better to assign a cluster as "Immune" with high confidence than to force a guess between "T Cell" and "B Cell" when the evidence is insufficient.'}),"\n",(0,r.jsx)(n.h3,{id:"marker-hierarchy-structure",children:"Marker Hierarchy Structure"}),"\n",(0,r.jsx)(n.p,{children:"The hierarchy defines parent-child relationships between cell type categories. Each node has associated positive markers (and optionally anti-markers) that define its expression signature."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  ROOT   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u25bc          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502Epithelium\u2502                   \u2502 Immune    \u2502  ... (other roots)\n    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518                   \u2502  Cells    \u2502\n         \u2502                         \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n    \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510                    \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n    \u25bc         \u25bc                    \u25bc           \u25bc\n Ciliated  Glandular           Myeloids    Lymphoids\n                                   \u2502\n                              \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n                              \u25bc         \u25bc\n                         Granulocytes  Monocytes\n"})}),"\n",(0,r.jsx)(n.p,{children:"In this example:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Epithelium"})," and ",(0,r.jsx)(n.strong,{children:"Immune Cells"})," are root nodes - they compete at level 0"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Ciliated"})," and ",(0,r.jsx)(n.strong,{children:"Glandular"})," are siblings under Epithelium - they compete at level 1"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Myeloids"})," and ",(0,r.jsx)(n.strong,{children:"Lymphoids"})," are siblings under Immune Cells - they compete at level 1"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Granulocytes"})," and ",(0,r.jsx)(n.strong,{children:"Monocytes"})," are siblings under Myeloids - they compete at level 2"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:'A cluster assigned to "Myeloids" will never be compared against "Ciliated" because they exist in different branches of the hierarchy.'}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"gate-check-sequence",children:"Gate Check Sequence"}),"\n",(0,r.jsx)(n.p,{children:"Before a node can be considered as a candidate for assignment, it must pass a series of gate checks. These gates filter out nodes that lack sufficient evidence, ensuring only well-supported candidates compete for selection."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  GATE CHECKS (in order)                                                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                         \u2502\n\u2502  Level 0 only:                                                          \u2502\n\u2502  \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557  \u2502\n\u2502  \u2551 CHECK 1: root_hard_requirements                                   \u2551  \u2502\n\u2502  \u2551   IF marker pos_frac < required \u2192 REJECT                          \u2551  \u2502\n\u2502  \u2551   IF marker enrichment < required \u2192 REJECT                        \u2551  \u2502\n\u2502  \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563  \u2502\n\u2502  \u2551 CHECK 2: root_veto_markers                                        \u2551  \u2502\n\u2502  \u2551   IF veto marker pos_frac > max_allowed \u2192 REJECT                  \u2551  \u2502\n\u2502  \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d  \u2502\n\u2502                                                                         \u2502\n\u2502  All levels:                                                            \u2502\n\u2502  \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557  \u2502\n\u2502  \u2551 CHECK 3: coverage                                                 \u2551  \u2502\n\u2502  \u2551   IF coverage < min_coverage[level] \u2192 REJECT                      \u2551  \u2502\n\u2502  \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563  \u2502\n\u2502  \u2551 CHECK 4: positive fraction (OR gate)                              \u2551  \u2502\n\u2502  \u2551   pos_ok = mean_positive_fraction >= min_pos_frac[level]          \u2551  \u2502\n\u2502  \u2551   frac_ok = frac_markers_on >= min_frac_markers_on[level]         \u2551  \u2502\n\u2502  \u2551   IF NOT pos_ok AND NOT frac_ok \u2192 REJECT                          \u2551  \u2502\n\u2502  \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563  \u2502\n\u2502  \u2551 CHECK 5: enrichment                                               \u2551  \u2502\n\u2502  \u2551   IF mean_enrichment < min_enrichment[level] \u2192 REJECT             \u2551  \u2502\n\u2502  \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563  \u2502\n\u2502  \u2551 CHECK 6: anti-marker conflict                                     \u2551  \u2502\n\u2502  \u2551   IF anti_penalty > anti_penalty_hard_gate (1.0) \u2192 REJECT         \u2551  \u2502\n\u2502  \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d  \u2502\n\u2502                                                                         \u2502\n\u2502  All checks passed \u2192 ACCEPT                                             \u2502\n\u2502                                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(n.h3,{id:"gate-check-details",children:"Gate Check Details"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"CHECK 1: Root Hard Requirements"})," (Level 0 only)"]}),"\n",(0,r.jsx)(n.p,{children:"Some root categories have mandatory markers that must be expressed. For example, Immune cells typically require CD45 expression. If a cluster lacks CD45, it cannot be assigned to Immune regardless of other marker evidence."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"pos_frac threshold"}),": Minimum fraction of cells expressing the required marker"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"enrichment threshold"}),": Minimum log-fold enrichment vs. global background"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"CHECK 2: Root Veto Markers"})," (Level 0 only)"]}),"\n",(0,r.jsx)(n.p,{children:"Certain markers actively exclude assignment to a root. For example, high Pan-Cytokeratin expression (an epithelial marker) should veto Immune assignment. This prevents lineage misclassification even when some markers are shared."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"CHECK 3: Coverage"})}),"\n",(0,r.jsx)(n.p,{children:"Coverage measures what fraction of the node's expected markers are actually present in the panel. Low coverage means insufficient evidence to make a decision. The threshold relaxes at deeper levels because specialized subtypes often have fewer defining markers."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"CHECK 4: Positive Fraction (OR Gate)"})}),"\n",(0,r.jsx)(n.p,{children:"This is a dual-condition gate - either condition passing is sufficient:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"pos_ok"}),": The average positive fraction across markers exceeds the threshold"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"frac_ok"}),': A sufficient fraction of individual markers are "on" (above their own thresholds)']}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The OR logic allows assignment when either the overall signal is strong OR when multiple markers show consistent (if weaker) positivity."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"CHECK 5: Enrichment"})}),"\n",(0,r.jsx)(n.p,{children:"Mean enrichment must exceed the level-specific threshold. Negative thresholds at deeper levels allow assignment even when expression is slightly below global average, which can occur for rare cell types."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"CHECK 6: Anti-Marker Conflict"})}),"\n",(0,r.jsx)(n.p,{children:"Anti-markers are markers that should be OFF for a given cell type. If anti-markers show strong expression (anti_penalty > 1.0), the node is rejected. This prevents assigning a cluster to a cell type when contradictory evidence is present."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"base-gating-parameters",children:"Base Gating Parameters"}),"\n",(0,r.jsx)(n.p,{children:"The gating thresholds vary by hierarchy level. Deeper levels have relaxed thresholds because:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Specialized subtypes often have fewer and weaker distinguishing markers"}),"\n",(0,r.jsx)(n.li,{children:"Once the lineage is established, less evidence is needed for subtype decisions"}),"\n",(0,r.jsx)(n.li,{children:"The hierarchy structure itself provides contextual constraint"}),"\n"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Level"}),(0,r.jsx)(n.th,{children:"min_coverage"}),(0,r.jsx)(n.th,{children:"min_pos_frac"}),(0,r.jsx)(n.th,{children:"min_enrichment"}),(0,r.jsx)(n.th,{children:"min_gap"}),(0,r.jsx)(n.th,{children:"min_frac_markers_on"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"0 (Root)"}),(0,r.jsx)(n.td,{children:"0.50"}),(0,r.jsx)(n.td,{children:"0.30"}),(0,r.jsx)(n.td,{children:"0.00"}),(0,r.jsx)(n.td,{children:"0.50"}),(0,r.jsx)(n.td,{children:"0.40"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"0.40"}),(0,r.jsx)(n.td,{children:"0.20"}),(0,r.jsx)(n.td,{children:"-0.50"}),(0,r.jsx)(n.td,{children:"0.30"}),(0,r.jsx)(n.td,{children:"0.30"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"2"}),(0,r.jsx)(n.td,{children:"0.30"}),(0,r.jsx)(n.td,{children:"0.15"}),(0,r.jsx)(n.td,{children:"-1.00"}),(0,r.jsx)(n.td,{children:"0.20"}),(0,r.jsx)(n.td,{children:"0.25"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"3+"}),(0,r.jsx)(n.td,{children:"0.30"}),(0,r.jsx)(n.td,{children:"0.15"}),(0,r.jsx)(n.td,{children:"-1.00"}),(0,r.jsx)(n.td,{children:"0.20"}),(0,r.jsx)(n.td,{children:"0.25"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"parameter-interpretation",children:"Parameter Interpretation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"min_coverage"}),": Minimum fraction of expected markers present in panel"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"min_pos_frac"}),": Minimum mean positive fraction across markers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"min_enrichment"}),": Minimum mean log-enrichment (negative values allow below-average expression)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"min_gap"}),": Minimum score difference between winner and runner-up (for confident selection)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"min_frac_markers_on"}),': Minimum fraction of markers that are individually "on"']}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["These parameters can be adjusted via the configuration system. See the ",(0,r.jsx)(n.a,{href:"/CellType-Refinery/docs/methodology/tuning-guide",children:"Tuning Guide"})," for optimization strategies."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"assignment-algorithm",children:"Assignment Algorithm"}),"\n",(0,r.jsx)(n.p,{children:"The algorithm proceeds in a top-down fashion, first selecting the best root category, then descending through the hierarchy until reaching a leaf node or encountering uncertainty."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:'\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  HIERARCHICAL ASSIGNMENT ALGORITHM                                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                         \u2502\n\u2502  For each cluster:                                                      \u2502\n\u2502                                                                         \u2502\n\u2502  1. IDENTIFY ROOTS                                                      \u2502\n\u2502     \u2022 Extract labels that are never children (Epithelium, Immune, ...)  \u2502\n\u2502                                                                         \u2502\n\u2502  2. EVALUATE ROOTS                                                      \u2502\n\u2502     \u2022 Check root_hard_requirements (e.g., CD45 for Immune)              \u2502\n\u2502     \u2022 Check root_veto_markers (e.g., Pan-CK blocks Immune)              \u2502\n\u2502     \u2022 Check standard gates (coverage, pos_frac, enrichment)             \u2502\n\u2502     \u2022 Collect passing roots                                             \u2502\n\u2502                                                                         \u2502\n\u2502  3. SELECT BEST ROOT                                                    \u2502\n\u2502     \u2022 Sort passing roots by score                                       \u2502\n\u2502     \u2022 If margin < root_gap_threshold (0.25): ambiguous_root             \u2502\n\u2502     \u2022 Otherwise: proceed with best root                                 \u2502\n\u2502                                                                         \u2502\n\u2502  4. DESCEND HIERARCHY                                                   \u2502\n\u2502     \u2022 Get children of current node                                      \u2502\n\u2502     \u2022 Check gates for each child (level-appropriate thresholds)         \u2502\n\u2502     \u2022 Sort passing children by score                                    \u2502\n\u2502     \u2022 If no children pass: stop_reason = "no_child_passed"              \u2502\n\u2502     \u2022 If gap < min_gap[level]: stop_reason = "ambiguous_siblings"       \u2502\n\u2502     \u2022 Otherwise: select best child, continue descent                    \u2502\n\u2502                                                                         \u2502\n\u2502  5. RECORD RESULT                                                       \u2502\n\u2502     \u2022 assigned_label = final node reached                               \u2502\n\u2502     \u2022 confidence = min_margin_along_path                                \u2502\n\u2502     \u2022 stop_reason = reason for stopping                                 \u2502\n\u2502                                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n'})}),"\n",(0,r.jsx)(n.h3,{id:"algorithm-pseudocode",children:"Algorithm Pseudocode"}),"\n",(0,r.jsx)(n.p,{children:"The following pseudocode illustrates the core assignment logic:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def assign_label(cluster, hierarchy):\n    # Step 1: Find best root\n    passing_roots = [r for r in roots if passes_gate(cluster, r)]\n    if not passing_roots:\n        return "Unassigned", "no_root_passed"\n\n    best_root = max(passing_roots, key=score)\n    if gap_to_runner_up < root_gap_threshold:\n        return best_root, "ambiguous_root"\n\n    # Step 2: Descend through hierarchy\n    current = best_root\n    while has_children(current):\n        children = get_children(current)\n        passing = [c for c in children if passes_gate(cluster, c)]\n\n        if not passing:\n            return current, "no_child_passed"\n\n        best_child = max(passing, key=score)\n        gap = best_child.score - runner_up.score\n\n        if gap < min_gap[level]:\n            return current, "ambiguous_siblings"\n\n        current = best_child\n\n    return current, "leaf_reached"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"key-decision-points",children:"Key Decision Points"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Root Selection"}),": The algorithm first identifies which root category (lineage) the cluster belongs to. This is the most critical decision because it constrains all downstream choices."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Gate Filtering"}),": At each level, only nodes that pass all gate checks are considered as candidates. This prevents weak evidence from influencing decisions."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Score-Based Ranking"}),": Among passing candidates, nodes are ranked by their composite score (see ",(0,r.jsx)(n.a,{href:"/CellType-Refinery/docs/methodology/marker-scoring-algorithm",children:"Marker Scoring Algorithm"}),")."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Gap-Based Confidence"}),": The algorithm checks if the margin between the best and second-best candidate exceeds the level-specific threshold. If not, it stops and reports ambiguity."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Descent Termination"}),": The algorithm stops when it reaches a leaf node, encounters ambiguity, or when no children pass gates."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"stop-reasons-explained",children:"Stop Reasons Explained"}),"\n",(0,r.jsx)(n.p,{children:"The algorithm records why it stopped descending, providing diagnostic information for result interpretation and downstream refinement."}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Stop Reason"}),(0,r.jsx)(n.th,{children:"Meaning"}),(0,r.jsx)(n.th,{children:"Assigned Label"}),(0,r.jsx)(n.th,{children:"What to Do"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"leaf_reached"})}),(0,r.jsx)(n.td,{children:"Best case - reached deepest level"}),(0,r.jsx)(n.td,{children:"Deepest node"}),(0,r.jsx)(n.td,{children:"None needed"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"ambiguous_siblings"})}),(0,r.jsx)(n.td,{children:"Top 2 children too close"}),(0,r.jsx)(n.td,{children:"Parent node"}),(0,r.jsx)(n.td,{children:"Consider refinement in Stage I"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"no_child_passed"})}),(0,r.jsx)(n.td,{children:"All children failed gates"}),(0,r.jsx)(n.td,{children:"Current node"}),(0,r.jsx)(n.td,{children:"Check marker coverage"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"no_root_passed"})}),(0,r.jsx)(n.td,{children:"No root category fit"}),(0,r.jsx)(n.td,{children:'"Unassigned"'}),(0,r.jsx)(n.td,{children:"Check panel, lower thresholds"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"ambiguous_root"})}),(0,r.jsx)(n.td,{children:"Top 2 roots too close"}),(0,r.jsx)(n.td,{children:'"Root1~Root2"'}),(0,r.jsx)(n.td,{children:"Check root markers"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"detailed-stop-reason-analysis",children:"Detailed Stop Reason Analysis"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"leaf_reached"})}),"\n",(0,r.jsx)(n.p,{children:"This is the ideal outcome. The algorithm descended all the way to a leaf node with confident decisions at every level. The assigned label is as specific as the hierarchy allows."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"ambiguous_siblings"})}),"\n",(0,r.jsx)(n.p,{children:"The two top-scoring children at some level had scores too close together (gap < min_gap). Rather than making an uncertain call, the algorithm assigns the parent label. This preserves accuracy at the cost of specificity."}),"\n",(0,r.jsx)(n.p,{children:'For example, if "T Cell" and "B Cell" both score highly under "Lymphoid" with insufficient gap, the cluster is assigned "Lymphoid" with stop_reason="ambiguous_siblings".'}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"no_child_passed"})}),"\n",(0,r.jsx)(n.p,{children:"All children of the current node failed gate checks. This often indicates:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Missing markers in the panel for the expected subtypes"}),"\n",(0,r.jsx)(n.li,{children:"A true intermediate or transitional cell state"}),"\n",(0,r.jsx)(n.li,{children:"Thresholds that are too stringent for the data"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The cluster is assigned to the current (parent) node."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"no_root_passed"})}),"\n",(0,r.jsx)(n.p,{children:'No root category passed all gate checks. This results in an "Unassigned" label and typically indicates:'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Clusters of low-quality cells or doublets"}),"\n",(0,r.jsx)(n.li,{children:"Cell types not represented in the marker hierarchy"}),"\n",(0,r.jsx)(n.li,{children:"Panel design issues (missing key lineage markers)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"ambiguous_root"})}),"\n",(0,r.jsx)(n.p,{children:'Two or more root categories scored too closely. The label is formatted as "Root1~Root2" to indicate the ambiguity. This can happen with:'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Doublets containing cells from multiple lineages"}),"\n",(0,r.jsx)(n.li,{children:"Rare hybrid cell types"}),"\n",(0,r.jsx)(n.li,{children:"Panel limitations preventing clear lineage discrimination"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"confidence-calculation",children:"Confidence Calculation"}),"\n",(0,r.jsx)(n.p,{children:"Each assignment includes a confidence score that reflects the minimum margin encountered along the assignment path."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"confidence = min_margin_along_path\n\nWhere margin at each level = winner_score - runner_up_score\n\nSpecial cases:\n  \u2022 No competition (single candidate): margin = infinity \u2192 sentinel 1e6\n  \u2022 no_root_passed: confidence = 0.0\n"})}),"\n",(0,r.jsx)(n.h3,{id:"confidence-interpretation",children:"Confidence Interpretation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"High confidence (> 1.0)"}),": Clear winner at every level; robust assignment"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Moderate confidence (0.3 - 1.0)"}),": Generally reliable but some levels had closer competition"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Low confidence (< 0.3)"}),": Assignment is tentative; consider for manual review"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The confidence score is the ",(0,r.jsx)(n.strong,{children:"minimum"})," margin along the path, not the average. This means a single close call anywhere in the hierarchy will lower the overall confidence, which is appropriate since uncertainty at any level propagates to the final assignment."]}),"\n",(0,r.jsx)(n.h3,{id:"margin-calculation-example",children:"Margin Calculation Example"}),"\n",(0,r.jsx)(n.p,{children:"Consider a path: Root (Immune) -> Lymphoid -> T Cell"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Root level: Immune scores 2.5, Epithelium scores 1.0 -> margin = 1.5"}),"\n",(0,r.jsx)(n.li,{children:"Level 1: Lymphoid scores 1.8, Myeloid scores 0.9 -> margin = 0.9"}),"\n",(0,r.jsx)(n.li,{children:"Level 2: T Cell scores 1.2, B Cell scores 0.8 -> margin = 0.4"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"confidence = min(1.5, 0.9, 0.4) = 0.4"})}),"\n",(0,r.jsx)(n.p,{children:"The close competition between T Cell and B Cell dominates the confidence, even though root selection was highly confident."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"per-cell-voting-evidence-collection",children:"Per-Cell Voting (Evidence Collection)"}),"\n",(0,r.jsx)(n.p,{children:"When siblings are too close (ambiguous_siblings), the algorithm performs per-cell voting to gather additional evidence. This information is stored for potential use in downstream refinement stages."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:'\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551  CRITICAL: Voting is EVIDENCE ONLY                                    \u2551\n\u2551                                                                       \u2551\n\u2551  \u2022 assigned_label = PARENT (not any child)                            \u2551\n\u2551  \u2022 stop_reason = "ambiguous_siblings" (not "voted")                   \u2551\n\u2551  \u2022 Composition stored for audit and Stage I refinement hints          \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n'})}),"\n",(0,r.jsx)(n.h3,{id:"how-per-cell-voting-works",children:"How Per-Cell Voting Works"}),"\n",(0,r.jsx)(n.p,{children:"When the cluster-level decision is ambiguous:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Individual cell scoring"}),": Each cell in the cluster is scored against the competing siblings"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Vote assignment"}),': Each cell "votes" for its highest-scoring candidate']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Composition recording"}),": The vote distribution is stored (e.g., 60% T Cell, 40% B Cell)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"important-constraints",children:"Important Constraints"}),"\n",(0,r.jsxs)(n.p,{children:["Per-cell voting does ",(0,r.jsx)(n.strong,{children:"not"}),' change the assignment. The label remains the parent node, and the stop_reason remains "ambiguous_siblings". The voting information is purely diagnostic.']}),"\n",(0,r.jsx)(n.p,{children:"This design prevents over-commitment to uncertain calls. If the cluster truly contains a mixture of cell types, this will be addressed in refinement stages where clusters can be split."}),"\n",(0,r.jsx)(n.h3,{id:"voting-output-format",children:"Voting Output Format"}),"\n",(0,r.jsx)(n.p,{children:"The voting results are stored in the cluster metadata:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'{\n    "cluster_id": 42,\n    "assigned_label": "Lymphoid",\n    "stop_reason": "ambiguous_siblings",\n    "ambiguous_candidates": ["T Cell", "B Cell"],\n    "cell_votes": {\n        "T Cell": 0.62,\n        "B Cell": 0.38\n    },\n    "recommendation": "consider_split"  # or "likely_homogeneous"\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"handling-edge-cases",children:"Handling Edge Cases"}),"\n",(0,r.jsx)(n.h3,{id:"missing-markers",children:"Missing Markers"}),"\n",(0,r.jsx)(n.p,{children:"When key markers are missing from the panel, the algorithm adapts:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Coverage check fails"}),": If too few markers are present, the node is rejected"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reduced discrimination"}),": Available markers may not distinguish between siblings"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Conservative assignment"}),": The algorithm stops at a higher level rather than guessing"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"single-child-nodes",children:"Single-Child Nodes"}),"\n",(0,r.jsx)(n.p,{children:"Some hierarchy nodes may have only one child. In these cases:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"If the child passes gates, it is automatically selected (no competition)"}),"\n",(0,r.jsx)(n.li,{children:'The margin is set to the sentinel value (1e6) indicating "no competition"'}),"\n",(0,r.jsx)(n.li,{children:"This does not reduce confidence since there was no ambiguity"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"negative-markers-only",children:"Negative Markers Only"}),"\n",(0,r.jsx)(n.p,{children:"Some cell types are defined primarily by what they do NOT express (e.g., CD4-/CD8- T cells). The algorithm handles this through:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Anti-marker scoring contributing to the overall score"}),"\n",(0,r.jsx)(n.li,{children:"Gate checks on positive fraction can be bypassed if sufficient anti-marker evidence exists"}),"\n",(0,r.jsx)(n.li,{children:"Coverage calculations include negative markers in the denominator"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsx)(n.p,{children:"The hierarchical structure provides significant computational efficiency:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pruning"}),": Once a root is selected, all other branches are ignored"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Early stopping"}),": Ambiguous decisions prevent unnecessary computation on deeper levels"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parallelization"}),": Different clusters can be processed independently"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For large datasets, the algorithm scales linearly with the number of clusters, not with the size of the hierarchy."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/CellType-Refinery/docs/methodology/marker-scoring-algorithm",children:"Marker Scoring Algorithm"})," - How individual node scores are calculated"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/CellType-Refinery/docs/methodology/refinement-decision-logic",children:"Refinement Decision Logic"})," - What happens after initial assignment"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/CellType-Refinery/docs/methodology/tuning-guide",children:"Tuning Guide"})," - How to adjust parameters for your data"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453(e,n,i){i.d(n,{R:()=>l,x:()=>o});var s=i(6540);const r={},t=s.createContext(r);function l(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);